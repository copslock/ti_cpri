.. _pub_keystore_provision:

=====================
Keystore Provisioning
=====================

This document contains the information needed to generate the payload contents
used by the :ref:`TISCI_MSG_KEYSTORE_WRITE <keystore_write>` API for initial
keystore provisioning.

1. :ref:`Creating the keystore structure <create_keystore>`
2. :ref:`Encrypting and signing the keystore contents <enc_sign_keystore>`

Introduction
============

Runtime keystore in |sysfw| is maintained through a data structure in DMSC
internal memory. All keys are stored in plaintext form for internal use by
various runtime key services and are only ever exposed externally in encrypted
form. In addition to the key parameters, additional metadata is managed,
including individual key slot ownership and usage permissions, which key slots
contain valid keys, keystore partitioning details, and internal state
information.

The system designer is responsible for establishing a root of trust with the
device to unlock the keystore for provisioning of initial contents. This
action includes:

* Injecting primary set of keys
* Specifying permissions for all key slots
* Assigning ownership for the keystore structure

.. _create_keystore:

Creating the keystore structure
===============================

Keystore contents will be written directly into |sysfw| internal memory using
the keystore write API. The data must be be packed into a structure which is
understood by |sysfw| and is defined below. The user is responsible for creating
this structure in their own HSM.

Data structures
---------------

The below data structures represent the keystore and various key data and
metadata it contains. Keystore write payload (in plaintext form) must match this
format to guarantee that |sysfw| internally can comprehend the same structure
and use to properly reference for subsequent key operations.

The following sections describe in detail the structues used in the keystore:

+------------------------------------------------+------------------------------------------------------+
| Structure                                      | Description                                          |
+================================================+======================================================+
| :ref:`keystore_state <keystore_state_def>`     | Definition of keystore holding all keys and metadata |
+------------------------------------------------+------------------------------------------------------+
| :ref:`keystore_key_cfg <keystore_key_cfg_def>` | Metadata for each key index in the keystore          |
+------------------------------------------------+------------------------------------------------------+
| :ref:`rsa_privkey <rsa_privkey_def>`           | RSA private key                                      |
+------------------------------------------------+------------------------------------------------------+
| :ref:`rsa_pubkey <rsa_pubkey_def>`             | RSA public key                                       |
+------------------------------------------------+------------------------------------------------------+
| :ref:`ec_pubkey <ec_pubkey_def>`               | EC public key                                        |
+------------------------------------------------+------------------------------------------------------+
| :ref:`ec_privkey <ec_privkey_def>`             | EC private key                                       |
+------------------------------------------------+------------------------------------------------------+

.. _keystore_state_def:

Keystore State
~~~~~~~~~~~~~~

The keystore state structure contains a collection of user keys, key metadata,
and keystore information. It is statically defined to hold a predetermined
amount of symmetric and asymmetric key slots which are allocated for their
worst-case memory size:

* Symmetric key slots are 32 bytes to accommodate up to 256-bit keys and are
  used to hold any symmetric key size/type
* Asymmetric key slots are 2400 bytes to accommodate up to 4K RSA private key
  parameters and are used to hold all RSA/EC public or private keys

The below shows how keystore is currently defined in |sysfw|:

.. code-block:: c

  /**
   * \brief Module global state
   *
   * \param skey_cfg Symmetric key host/usage permissions
   * \param skey_status Symmetric key import status
   * \param skey Symmetric key value imported
   * \param askey_cfg Asymmetric key host/usage permissions
   * \param askey_status Asymmetric key import status
   * \param askey_type Asymmetric key type (rsa or ec)
   * \param askey Asymmetric key value imported
   * \param owner Host ID of the host who owns the keystore structure. The
   *              ownership will be determined during key provisioning through the
   *              payload details contained in the keystore write API. Only the
   *              owner will be able to trigger bulk keystore export and import.
   * \param reserved Reserved
   */
  struct {
	struct keystore_key_cfg skey_cfg[KEYSTORE_NUM_SKEYS_MAX];
	u8			skey_status[KEYSTORE_NUM_SKEYS_MAX];
	u8			skey[KEYSTORE_NUM_SKEYS_MAX][
		KEYSTORE_SKEY_KEY_LEN];
	struct keystore_key_cfg askey_cfg[KEYSTORE_NUM_ASKEYS_MAX];
	u8			askey_status[KEYSTORE_NUM_ASKEYS_MAX];
	u8			askey_type[KEYSTORE_NUM_ASKEYS_MAX];
	union {
		struct rsa_privkey	rsa;
		struct rsa_pubkey	rsa_pub;
		struct ec_privkey	ec;
		struct ec_pubkey	ec_pub;
	} askey[KEYSTORE_NUM_ASKEYS_MAX];
	u8	owner;
	u8	reserved;
  } keystore_state;

Some size and number macro definitions are listed below to fill in details on
the size of each of the arrays:

.. code-block:: c

  /**
   * Maximum number of imported symmetric keys
   */
  #define KEYSTORE_NUM_SKEYS_MAX           (8U)

  /** Key size used for symmetric key store */
  #define KEYSTORE_SKEY_KEY_LEN            (32U)

  /* Maximum number of asymmetric keys */
  #define KEYSTORE_NUM_ASKEYS_MAX          (4U)

.. note::

  The macros indicating the size are temporary and only relevant in the context
  of statically-partitioned keystore memory.  When the keystore supports the
  runtime configuration of partitioning then the above macros will become
  obsolete.

`skey_status` and `askey_status` defines whether the key slot holds a valid key
or not. If the key slot does not contains a key, it is set to zero.  If the slot
contains a valid key, it must be initialized with the special value below:

.. code-block:: c

  /**
   * flag indicating if the key import status was OK
   */
  #define KEYSTORE_KEY_IMPORT_STATUS_OK          0x5AU

Asymmetric keys are distinguished with the `askey_type` parameter below:

.. code-block:: c

  /* Public key crypto algo types */
  #define PK_TYPE_RSA                       0
  #define PK_TYPE_EC                        1

.. _keystore_key_cfg_def:

Keystore Key Config
~~~~~~~~~~~~~~~~~~~

The `keystore_key_cfg` determines host access and usage permissions for each key
slot. The definition is as follows:

.. code-block:: c

  /**
   * \brief Configuration info for one key item
   *
   * \struct keystore_key_cfg
   *
   * \param owner Owner of this item
   * \param usage_flags Or'ed value of KEYSTORE_[AS]KEY_USAGE* flags
   */
  struct keystore_key_cfg {
	u8	owner;
	u32	usage_flags;
  } __attribute__((packed));

`owner` is the Host ID. Host ownership is assigned to each individual key slot to
limit operations using the keys based on a host identifier.  This contrasts
`owner` of the keystore structure which determines who will be able to
export/import the entire keystore contents. See specific Host ID enumerations
for the particular :ref:`SoC family of interest<pub_soc_family_doc>` for details
on valid values.

`usage_flags` are a bitwise-OR of various operation types defined for symmetric
and asymmetric keys. Each key slot may be specified to restrict usage to some
or all of the operations as defined below.

.. note::

  Key usage permissions are not fully defined at this time and will be
  introduced in a later release. All keys are to remain available for all usage
  types until further specified. Until then, `usage_flags` will be ignored and
  should be programmed with **all bits set to 1** to protect for future
  compatibility:

.. code-block:: c

  /* Flag indicating that the key is open for all usages */
  #define KEYSTORE_USAGE_FLAGS_ALL_OPEN     (0xFFFFFFFFU)


.. _rsa_privkey_def:

RSA Private Key
~~~~~~~~~~~~~~~

The following provides a description of the RSA private key parameters:

.. code-block:: c

  /* RSA keys */
  #define RSA_KEY_E_MAXLEN                  (8U)
  #define RSA_KEY_N_MAXLEN                  (520U)
  #define RSA_KEY_PQ_MAXLEN                 ((RSA_KEY_N_MAXLEN / 2U) + 4U)

  /**
   * \brief RSA private key. All values are in biginteger format (size followed
   *        by word value array, least significant word first)
   *
   * \param n RSA modulus (n)
   * \param e Public exponent (e)
   * \param d Private exponent (d)
   * \param p Prime 1 (p)
   * \param q Prime 2 (q)
   * \param dp d mod (p-1)
   * \param dq d mod (q-1)
   * \param coefficient crt coefficient q^(-1) mod p
   */
  struct rsa_privkey {
	u32	n[BIGINT_LEN(RSA_KEY_N_MAXLEN)];
	u32	e[BIGINT_LEN(RSA_KEY_E_MAXLEN)];
	u32	d[BIGINT_LEN(RSA_KEY_N_MAXLEN)];
	u32	p[BIGINT_LEN(RSA_KEY_PQ_MAXLEN)];
	u32	q[BIGINT_LEN(RSA_KEY_PQ_MAXLEN)];
	u32	dp[BIGINT_LEN(RSA_KEY_PQ_MAXLEN)];
	u32	dq[BIGINT_LEN(RSA_KEY_PQ_MAXLEN)];
	u32	coefficient[BIGINT_LEN(RSA_KEY_PQ_MAXLEN)];
  };

.. _rsa_pubkey_def:

RSA Public Key
~~~~~~~~~~~~~~

The following provides a description of the RSA public key parameters:

.. code-block:: c

  /**
   * \brief RSA public key. All values are in biginteger format (size followed
   *        by word value array, least significant word first)
   *
   * \param n RSA modulus (n)
   * \param e Public exponent (e)
   */
  struct rsa_pubkey {
	u32	n[BIGINT_LEN(RSA_KEY_N_MAXLEN)];
	u32	e[BIGINT_LEN(RSA_KEY_E_MAXLEN)];
  };

.. _ec_pubkey_def:

EC Public Key
~~~~~~~~~~~~~

The following provides a description of the EC public key parameters:

.. code-block:: c

  /**
   * Maximum length of a big integer used in EC crypto in bytes, enough to
   * accomodate 521-bit prime curves
   */
  #define EC_PARAM_MAXLEN                 (68U)

  /* ECDSA known curves */
  #define EC_CURVE_BRAINPOOL_P256R1         0
  #define EC_CURVE_BRAINPOOL_P256T1         1
  #define EC_CURVE_BRAINPOOL_P320R1         2
  #define EC_CURVE_BRAINPOOL_P320T1         3
  #define EC_CURVE_BRAINPOOL_P384R1         4
  #define EC_CURVE_BRAINPOOL_P384T1         5
  #define EC_CURVE_BRAINPOOL_P512R1         6
  #define EC_CURVE_BRAINPOOL_P512T1         7
  #define EC_CURVE_PRIME256V1               8
  #define EC_CURVE_SECP256K1                9
  #define EC_CURVE_SECP384R1                10
  #define EC_CURVE_SECP521R1                11
  #define EC_CURVE_N_ITEMS                  12

  #define EC_CURVE_EXPLICIT                (-1)

  /**
   * \brief EC prime curve parameters
   *
   * \param prime Prime number for the group
   * \param order Order of the group
   * \param a "a" parameter in the equation x^3 + ax + b = y
   * \param b "b" parameter in the equation x^3 + ax + b = y
   * \param g Generator point on the Elliptic curve
   */
  struct ec_prime_curve_p {
	u32		prime[BIGINT_LEN(EC_PARAM_MAXLEN)];
	u32		order[BIGINT_LEN(EC_PARAM_MAXLEN)];
	u32		a[BIGINT_LEN(EC_PARAM_MAXLEN)];
	u32		b[BIGINT_LEN(EC_PARAM_MAXLEN)];
	struct ec_point g;
  };

  /**
   * \brief EC Point, also the public key
   *
   * \param x x-coordinate
   * \param y y-coordinate
   */
  struct ec_point {
	u32	x[BIGINT_LEN(EC_PARAM_MAXLEN)];
	u32	y[BIGINT_LEN(EC_PARAM_MAXLEN)];
  };

  /*
   * \brief EC public key
   *
   * \param ec_curve_type One of EC_CURVE_* types
   * \param curve_params EC Curve parameters
   * \param public_key Public key value
   */
  struct ec_pubkey {
	s32			ec_curve_type;
	struct ec_prime_curve_p curve_params;
	struct ec_point		public_curve_point;
  };

.. _ec_privkey_def:

EC Private Key
~~~~~~~~~~~~~~

The following provides a description of the EC private key parameters:

.. code-block:: c

  /*
   * \brief EC private key
   *
   * \param ec_curve_type One of EC_CURVE_* types
   * \param curve_params EC Curve parameters
   * \param private_key Private key value
   * \param public_key Public key value
   */
  struct ec_privkey {
	s32			ec_curve_type;
	struct ec_prime_curve_p curve_params;
	u32			private_key[BIGINT_LEN(EC_PARAM_MAXLEN)];
	struct ec_point		public_curve_point;
  };

.. _bigint_data_format:

BIGINT data format
------------------

Asymmetric key operations are performed by a Public Key Accelerator (PKA)
hardware module which expects key parameters and input/output data blocks to be
in a particular format in order to generalize the operations across all key
types and sizes. |sysfw| enforces the data format referred to as BIGINT in order
to facilitate translation of these parameters to the PKA module.

BIGINT is a series of 32-bit words used to represent a little-endian byte stream
and the size of the stream. The first word will contain the size of the byte
stream in words, i.e.:

.. code-block:: c

  ceil(number_of_bytes_in_stream / 4)

Following the size word will be an array of words holding the LE byte array. An
example below shows a 10-byte data block in bytes and again in BIGINT format.
Note that the byte array is padded with extra zeros in the MSBs if it is too
small to completely fill the last BIGINT array slot.

.. code-block:: c

  /* Data block shown as a byte stream */
  u8 data_block[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99};

  /* Same data in BIGINT format:
   *   First word is the size = ceil(10/4) = 3
   *   Next 3 words contain the byte data (little endian)
   *   Last word padded with zeros to fill unused data
   */
  u32 data_block_bigint[] = {0x3, 0x33221100, 0x77665544, 0x00009988};

In general, for a given byte array, the BIGINT array size will be

.. code-block:: c

  /**
   * Length of a biginteger array in words, the +1 is for the size
   */
  #define BIGINT_LEN(bytelen)              (((bytelen + 3) / 4U) + 1U)

.. _enc_sign_keystore:

Encrypting and signing the keystore contents
============================================

:ref:`TISCI_MSG_KEYSTORE_WRITE <keystore_write>` payload requires that the
keystore contents be encrypted and signed. Successful validation and decryption
of the payload will unlock the keystore for writing to the internal structure.
The process for encrypting and signing mirrors how one :ref:`signs an encrypted
binary for secure boot <pub_sign_encrypted_mek>`.

1. Pad the binary with zeros until the length is a multiple of 16 bytes.

2. Append a 32 byte long random string to the binary output in step (1). This
   random string is used by |sysfw| to verify successful decryption. This string
   needs to be populated in the X509 certificate.

3. Choose 16 byte long random string as the initialization vector(IV) for CBC
   encryption. This string also needs to be populated in the X509 certificate.

4. Choose the key to encrypt the binary. |sysfw| only supports
   encryption with the active MEK.

5. Encrypt the binary output from step (2) with key chosen in step (4) in
   AES-256-CBC mode. Use the string chosen in step (3) as the initialization
   vector.

When using encryption, the X509 encryption extension needs to be populated in
the certificate before signing. The following changes apply to the other extensions.

1. The length of binary output in step (2) above needs to be populated in the
   X509 image integrity extension.

2. The binary output of step (5) needs to be used when calculating the hash to be
   populated in the X509 image integrity extension.

3. The binary output of step (5) must be appended to the signed X509 certificate
   instead of the unencrypted binary.

Please refer to :ref:`sysfw_image_integrity_ext` and :ref:`sysfw_encryption_ext`.
